/*!
 *  Bayrell Bundler
 *
 *  (c) Copyright 2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Bayrell.Bundler;

use Runtime.fs;
use Runtime.rs;
use Runtime.lib;
use Runtime.Task.TaskList;
use Runtime.Task.TaskMethod;
use Runtime.Task.TaskDriver;
use Bayrell.Bundler.BuildFile;
use Bayrell.Bundler.BuildModule;
use Bayrell.Bundler.BundlerHelper;
use Bayrell.Bundler.Inotify;
use Bayrell.Bundler.Module;


@TaskList{}
class Tasks
{
	
	/**
	 * Load files
	 * Chain: BundlerHelper::BUILD_MODULE
	 */
	async static BuildModule loadFiles(BuildModule build)
	{
		if (build.stop) return build;
		if (build.module == null) return build;
		
		string module_path = build.module.getPath();
		string path = fs::concat(module_path, "bay");
		
		bool exists = await fs::exists(path, @.base_path);
		if (exists)
		{
			Collection<string> files = await fs::readDirectoryRecursive(path, @.base_path);
			build <= module_path <= module_path;
			build <= files <= files;
		}
		
		return build;
	}
	
	
	
	/**
	 * Build
	 * Chain: BundlerHelper::BUILD_MODULE
	 */
	async static BuildModule build(BuildModule build)
	{
		if (build.stop) return build;
		if (build.files == null) return build;
		
		TaskDriver output = @.getDriver(classof TaskDriver);
		Dict json = @.config("Bayrell.Bundler");
		Collection<string> languages = json.get("languages");
		
		string files_path = fs::concat(build.module_path, "bay");
		for (int i=0; i<build.files.count(); i++)
		{
			string file_name = fs::concat(files_path, build.files.item(i));
			BuildFile file = new BuildFile
			{
				"relative_path": build.files.item(i),
				"file_path": file_name,
				"ext": rs::extname(file_name),
				"module": build.module,
				"languages": languages,
				"log_files": build.log_files,
			};
			
			/* Build file */
			BuildFile file = @.chain(BundlerHelper::BUILD_FILE_CHECK, [ file ]);
			if (not file.stop)
			{
				output.writeln( fs::concat(@.base_path, file_name) );
				file = await @.chainAwait(BundlerHelper::BUILD_FILE, [ file ]);
				
				/* Stop if error */
				if (file.parse_error != null)
				{
					/*return build;*/
				}
			}
		}
		
		return build;
	}
	
	
	
	/**
	 * Change File
	 */
	static async void onChangeFile(Inotify inotify, string file_name)
	{
		Dict json = @.config("Bayrell.Bundler");
		Collection<string> languages = json.get("languages");
		
		if (rs::strpos(file_name, @.base_path) != 0) return;
		
		string file_path = rs::substr( file_name, rs::strlen(@.base_path) );
		Module module = BundlerHelper::findModule(inotify.modules, file_path);
		
		if (module == null) return;
		
		/* Write file name */
		TaskDriver output = @.getDriver(classof TaskDriver);
		
		/* Create build container */
		BuildFile file = new BuildFile
		{
			"file_path": file_path,
			"ext": rs::extname(file_path),
			"module": module,
			"languages": languages,
		};
		
		/* Build file */
		BuildFile file = @.chain(BundlerHelper::BUILD_FILE_CHECK, [ file ]);
		if (not file.stop)
		{
			output.writeln( fs::concat(@.base_path, file_path) );
			await @.chainAwait(BundlerHelper::BUILD_FILE, [ file ]);
		}
	}
	
	
	
	/**
	 * Watch changes
	 */
	@TaskMethod{ "alias": "watch" }
	static async void watch()
	{
		Dict json = @.config("Bayrell.Bundler");
		TaskDriver output = @.getDriver(classof TaskDriver);
		Collection<string> modules_dir = json.get("modules", []);
		Collection<Module> modules = await BundlerHelper::getModules();
		
		/* Get notify driver */
		Inotify inotify = new Inotify("bundler-inotify");
		await inotify.createNotify();
		inotify.onChangeFile = method static::onChangeFile;
		inotify.changeTimeout = 500;
		inotify.modules = modules;
		@.addObject(inotify);
		
		for (int i=0; i<modules_dir.count(); i++)
		{
			string dir = modules_dir.item(i);
			string dir_path = fs::concat(@.base_path, dir);
			await inotify.addFolder(dir_path);
		}
		
		output.writeln("Start watch");
		while (true)
		{
			await rtl::sleep(100);
		}
	}
	
	
	
	/**
	 * Build project
	 */
	/*
	@TaskMethod{ "alias": "build" }
	static async void build()
	{
	}
	*/
	
	
	
	/**
	 * Show modules
	 */
	@TaskMethod{ "alias": "modules" }
	static async void modules()
	{
		TaskDriver output = @.getDriver(classof TaskDriver);
		Collection<string> modules = await BundlerHelper::getModules();
		
		/* Output list of modules */
		output.writeln("Modules:");
		modules.each
		(
			void (Module item) use (output)
			{
				output.writeln("  " ~ item.module_name)
			}
		);
	}
	
	
	
	/**
	 * Make symlink
	 */
	static async void make_link(string module_path, string assets_path, string kind)
	{
		TaskDriver output = @.getDriver(classof TaskDriver);
		string src = fs::concat(module_path, kind);
		string dest = fs::concat(assets_path, kind);
		string rel = fs::relative(assets_path, src);
		
		await fs::mkdir(assets_path, @.base_path);
		if (await fs::exists(src, @.base_path))
		{
			await fs::unlink(dest, @.base_path);
			await fs::symlink(rel, dest, @.base_path);
			output.writeln(fs::concat(@.base_path, dest) ~ " -> " ~ rel);
		}
	}
	
	
	
	/**
	 * Make symlinks
	 */
	@TaskMethod{ "alias": "make_symlinks" }
	static async void make_symlinks()
	{
		Collection<Module> modules = await BundlerHelper::getModules();
		for (int i=0; i<modules.count(); i++)
		{
			Module module = modules.item(i);
			
			string module_path = fs::concat(module.lib_path, module.module_name);
			string assets_path = fs::concat("/web/assets/", module.module_name);
			
			/* Resources folder */
			static::make_link(module_path, assets_path, "resources");
			
			/* ES6 folder */
			static::make_link(module_path, assets_path, "es6");
		}
		
	}
	
	
	
	/**
	 * Make module
	 */
	@TaskMethod{ "alias": "make" }
	static async void make()
	{
		int sz = @.cli_args.count();
		string module_name = @.cli_args.get(2, "");
		Collection<Module> modules = await BundlerHelper::getModules();
		TaskDriver output = @.getDriver(classof TaskDriver);
		Module module = modules.findItem( lib::equalAttr("module_name", module_name) );
		
		if (module_name == "")
		{
			output.writeln("Type module name:");
			modules.each
			(
				void (Module item) use (output)
				{
					output.writeln("  " ~ item.module_name)
				}
			);
			return;
		}
		else if (module == null)
		{
			output.writeln("Wrong module name " ~ module_name);
			return;
		}
		
		/* Chain module build */
		await @.chainAwait
		(
			BundlerHelper::BUILD_MODULE,
			[
				new BuildModule
				{
					"module": module,
					"log_files": false,
				}
			]
		);
		
	}
	
	
	
	/**
	 * Make all modules
	 */
	@TaskMethod{ "alias": "make_all" }
	static async void make_all()
	{
		Collection<Module> modules = await BundlerHelper::getModules();
		for (int i=0; i<modules.count(); i++)
		{
			Module module = modules.item(i);
			
			/* Chain module build */
			await @.chainAwait
			(
				BundlerHelper::BUILD_MODULE,
				[
					new BuildModule
					{
						"module": module,
						"log_files": false,
					}
				]
			);
		}
	}
	
}

